import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { filter } from 'rxjs/operators/filter';
import { InjectionToken, Inject, Injectable, ChangeDetectionStrategy, Component, Input, Output, EventEmitter, HostBinding, ElementRef, PLATFORM_ID, Directive, Renderer2, ComponentFactoryResolver, ViewContainerRef, NgModule } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { map } from 'rxjs/operators/map';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { tap } from 'rxjs/operators/tap';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { debounceTime } from 'rxjs/operators/debounceTime';
import { Subject } from 'rxjs/Subject';
import { switchMap } from 'rxjs/operators/switchMap';
import { zip } from 'rxjs/observable/zip';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @record
 */

/** @enum {string} */
const GalleryAction = {
    INITIALIZED: 'initialized',
    ITEMS_CHANGED: 'itemsChanged',
    INDEX_CHANGED: 'indexChanged',
    OPENED: 'opened',
    CLOSED: 'closed',
};
/**
 * @record
 */

/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Initial state
 */
const defaultState = {
    action: GalleryAction.INITIALIZED,
    currIndex: 0,
    hasNext: false,
    hasPrev: false,
    items: []
};
const defaultConfig = {
    gestures: true,
    panSensitivity: 25,
    counter: true,
    nav: true,
    dots: false,
    thumb: true,
    thumbWidth: 120,
    thumbHeight: 90,
    thumbPosition: 'bottom',
    disableThumb: false,
    slidingDirection: 'horizontal',
    zoomOut: 0
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryRef {
    /**
     * @param {?=} config
     * @param {?=} state
     */
    constructor(config = defaultConfig, state = defaultState) {
        this.config = config;
        this.state = state;
        this.state$ = new BehaviorSubject(state);
        this.config$ = new BehaviorSubject(defaultConfig);
        this.setConfig(config);
    }
    /**
     * Set gallery config
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this.config = Object.assign({}, defaultConfig, this.config, config);
        this.config$.next(this.config);
    }
    /**
     * Set gallery state
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        this.state = Object.assign({}, this.state, state);
        this.state$.next(this.state);
    }
    /**
     * Add gallery item
     * @param {?} item - Gallery item object
     * @param {?=} active - Set the new item as current slide
     * @return {?}
     */
    add(item, active) {
        const /** @type {?} */ items = [...this.state.items, item];
        this.setState({
            action: GalleryAction.ITEMS_CHANGED,
            items: items,
            hasNext: items.length > 1,
            currIndex: active ? items.length - 1 : this.state.currIndex
        });
    }
    /**
     * Remove gallery item
     * @param {?} i - Item index
     * @return {?}
     */
    remove(i) {
        const /** @type {?} */ items = [
            ...this.state.items.slice(0, i),
            ...this.state.items.slice(i + 1, this.state.items.length)
        ];
        this.setState({
            action: GalleryAction.ITEMS_CHANGED,
            items: items,
            hasNext: items.length > 1,
            hasPrev: i > 0
        });
    }
    /**
     * Load items and reset the state
     * @param {?} items - Gallery images data
     * @return {?}
     */
    load(items) {
        if (items) {
            this.setState({
                action: GalleryAction.ITEMS_CHANGED,
                items: items,
                hasNext: items.length > 1,
                hasPrev: false
            });
        }
    }
    /**
     * Set active item
     * @param {?} i - Active Index
     * @return {?}
     */
    set(i) {
        if (i !== this.state.currIndex) {
            this.setState({
                action: GalleryAction.INDEX_CHANGED,
                currIndex: i,
                hasNext: i < this.state.items.length - 1,
                hasPrev: i > 0
            });
        }
    }
    /**
     * Next item
     * @return {?}
     */
    next() {
        if (this.state.hasNext) {
            this.set(this.state.currIndex + 1);
        }
        else if (this.config.loop) {
            this.set(0);
        }
    }
    /**
     * Prev item
     * @return {?}
     */
    prev() {
        if (this.state.hasPrev) {
            this.set(this.state.currIndex - 1);
        }
        else if (this.config.loop) {
            this.set(this.state.items.length - 1);
        }
    }
    /**
     * Reset gallery to initial state
     * @return {?}
     */
    reset() {
        this.setState(defaultState);
    }
    /**
     * Destroy GalleryRef (for internal use only)
     * @return {?}
     */
    destroy() {
        this.state$.complete();
        this.config$.complete();
    }
    /**
     * Stream that emits when gallery is initialized/reset
     * @return {?}
     */
    initialized() {
        return this.state$.pipe(filter((state) => state.action === GalleryAction.INITIALIZED));
    }
    /**
     * Stream that emits when items is changed (items loaded, item added, item removed)
     * @return {?}
     */
    itemsChanged() {
        return this.state$.pipe(filter((state) => state.action === GalleryAction.ITEMS_CHANGED));
    }
    /**
     * Stream that emits when current item is changed
     * @return {?}
     */
    indexChanged() {
        return this.state$.pipe(filter((state) => state.action === GalleryAction.INDEX_CHANGED));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const GALLERY_CONFIG = new InjectionToken('galleryConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Gallery {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Stores GalleryRef instances
         */
        this._instances = {};
        this.config = Object.assign({}, defaultConfig, config);
    }
    /**
     * Returns Gallery by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    ref(id = 'root', config) {
        if (this._instances[id] instanceof GalleryRef) {
            return this._instances[id];
        }
        else {
            config = Object.assign({}, this.config, config);
            return this._instances[id] = new GalleryRef(config);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    destroy(id = 'root') {
        if (this._instances[id] instanceof GalleryRef) {
            this._instances[id].destroy();
            this._instances[id] = null;
        }
    }
    /**
     * @return {?}
     */
    destroyAll() {
        Object.keys(this._instances)
            .map((key) => {
            this._instances[key].destory();
            this._instances[key] = null;
        });
    }
    /**
     * @return {?}
     */
    resetAll() {
        Object.keys(this._instances)
            .map((id = 'root') => this._instances[id].gallery)
            .map((gallery) => gallery.reset());
    }
}
Gallery.decorators = [
    { type: Injectable },
];
/** @nocollapse */
Gallery.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [GALLERY_CONFIG,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ImageItemComponent {
}
ImageItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'image-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <div [lazyImage]="data?.src" (loading)="loading = $event"></div>
    <i class="g-loading" *ngIf="loading"></i>
  `,
                styles: [`
    :host {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;
    }
    div {
      background-position: center center;
      background-size: cover;
      width: 100%;
      height: 100%;
    }
  `],
            },] },
];
/** @nocollapse */
ImageItemComponent.ctorParameters = () => [];
ImageItemComponent.propDecorators = {
    "data": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class VideoItemComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
}
VideoItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'video-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: '<video controls [src]="sanitizer.bypassSecurityTrustResourceUrl(data?.src)"></video>',
                styles: [`
    video {
      position: absolute;
      width: 100%;
      height: 100%;
    }
  `]
            },] },
];
/** @nocollapse */
VideoItemComponent.ctorParameters = () => [
    { type: DomSanitizer, },
];
VideoItemComponent.propDecorators = {
    "data": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class IframeItemComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
}
IframeItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'iframe-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <iframe frameborder="0"
            allowfullscreen
            [src]="sanitizer.bypassSecurityTrustResourceUrl(data?.src)"></iframe>
  `,
                styles: [`
    iframe {
      position: absolute;
      width: 100%;
      height: 100%;
    }
  `]
            },] },
];
/** @nocollapse */
IframeItemComponent.ctorParameters = () => [
    { type: DomSanitizer, },
];
IframeItemComponent.propDecorators = {
    "data": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ThumbnailItemComponent {
}
ThumbnailItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'thumbnail-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <div [lazyImage]="data.thumbSrc"></div>
  `,
                styles: [`
    :host {
      width: 100%;
      height: 100%;
    }
    div {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center center;
    }
  `]
            },] },
];
/** @nocollapse */
ThumbnailItemComponent.ctorParameters = () => [];
ThumbnailItemComponent.propDecorators = {
    "data": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ImageItem {
    /**
     * @param {?} src
     * @param {?=} thumb
     */
    constructor(src, thumb) {
        this.component = ImageItemComponent;
        this.thumbComponent = ThumbnailItemComponent;
        this.data = {
            src: src,
            thumbSrc: thumb
        };
    }
}
class VideoItem {
    /**
     * @param {?} src
     * @param {?=} thumb
     */
    constructor(src, thumb) {
        this.component = VideoItemComponent;
        this.thumbComponent = ThumbnailItemComponent;
        this.data = {
            src: src,
            thumbSrc: thumb
        };
    }
}
class IframeItem {
    /**
     * @param {?} src
     * @param {?=} thumb
     */
    constructor(src, thumb) {
        this.component = IframeItemComponent;
        this.thumbComponent = ThumbnailItemComponent;
        this.data = {
            src: src,
            thumbSrc: thumb
        };
    }
}
class YoutubeItem {
    /**
     * @param {?} src
     * @param {?=} thumbSrc
     */
    constructor(src, thumbSrc) {
        this.component = IframeItemComponent;
        this.thumbComponent = ThumbnailItemComponent;
        this.data = {
            src: `//youtube.com/embed/${src}?wmode=transparent`,
            thumbSrc: thumbSrc ? thumbSrc : `//img.youtube.com/vi/${src}/default.jpg`
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryComponent {
    /**
     * @param {?} _gallery
     */
    constructor(_gallery) {
        this._gallery = _gallery;
        this.gestures = this._gallery.config.gestures;
        this.panSensitivity = this._gallery.config.panSensitivity;
        this.zoomOut = this._gallery.config.zoomOut;
        this.dots = this._gallery.config.dots;
        this.thumb = this._gallery.config.thumb;
        this.nav = this._gallery.config.nav;
        this.counter = this._gallery.config.counter;
        this.thumbWidth = this._gallery.config.thumbWidth;
        this.thumbHeight = this._gallery.config.thumbHeight;
        this.disableThumb = this._gallery.config.disableThumb;
        this.thumbPosition = this._gallery.config.thumbPosition;
        this.slidingDirection = this._gallery.config.slidingDirection;
        this.destroyRef = true;
        this.indexChange = new EventEmitter();
        this.itemsChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    getConfig() {
        return {
            gestures: this.gestures,
            panSensitivity: this.panSensitivity,
            zoomOut: this.zoomOut,
            counter: this.counter,
            nav: this.nav,
            dots: this.dots,
            thumb: this.thumb,
            thumbWidth: this.thumbWidth,
            thumbHeight: this.thumbHeight,
            thumbPosition: this.thumbPosition,
            disableThumb: this.disableThumb,
            slidingDirection: this.slidingDirection
        };
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onIndexChange(i) {
        switch (i) {
            case 'next':
                this.galleryRef.next();
                break;
            case 'prev':
                this.galleryRef.prev();
                break;
            default:
                this.galleryRef.set(i);
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.galleryRef instanceof GalleryRef) {
            this.galleryRef.setConfig(this.getConfig());
            if (this.items !== this.galleryRef.state.items) {
                this.load(this.items);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Get gallery instance by id
        this.galleryRef = this._gallery.ref(this.id);
        this.galleryRef.setConfig(this.getConfig());
        this.load(this.items);
        /** Subscribes to indexChange and itemsChange events when user bind them */
        if (this.indexChange.observers.length) {
            this._indexChange$ = this.galleryRef.indexChanged().subscribe((e) => this.indexChange.next(e));
        }
        if (this.itemsChange.observers.length) {
            this._itemChange$ = this.galleryRef.itemsChanged().subscribe((e) => this.itemsChange.next(e));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._indexChange$) {
            this._indexChange$.unsubscribe();
        }
        if (this._itemChange$) {
            this._itemChange$.unsubscribe();
        }
        if (this.destroyRef) {
            this.galleryRef.reset();
        }
    }
    /**
     * @param {?} items
     * @return {?}
     */
    load(items) {
        this.galleryRef.load(items);
    }
    /**
     * @param {?} item
     * @param {?=} active
     * @return {?}
     */
    add(item, active) {
        this.galleryRef.add(item, active);
    }
    /**
     * @param {?} i
     * @return {?}
     */
    remove(i) {
        this.galleryRef.remove(i);
    }
    /**
     * @return {?}
     */
    next() {
        this.galleryRef.next();
    }
    /**
     * @return {?}
     */
    prev() {
        this.galleryRef.prev();
    }
    /**
     * @param {?} i
     * @return {?}
     */
    set(i) {
        this.galleryRef.set(i);
    }
    /**
     * @return {?}
     */
    reset() {
        this.galleryRef.reset();
    }
}
GalleryComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <gallery-core [state]="galleryRef.state$ | async"
                  [config]="galleryRef.config$ | async"
                  (indexChange)="onIndexChange($event)"></gallery-core>
    <ng-content></ng-content>
  `
            },] },
];
/** @nocollapse */
GalleryComponent.ctorParameters = () => [
    { type: Gallery, },
];
GalleryComponent.propDecorators = {
    "id": [{ type: Input },],
    "items": [{ type: Input },],
    "gestures": [{ type: Input },],
    "panSensitivity": [{ type: Input },],
    "zoomOut": [{ type: Input },],
    "dots": [{ type: Input },],
    "thumb": [{ type: Input },],
    "nav": [{ type: Input },],
    "counter": [{ type: Input },],
    "thumbWidth": [{ type: Input },],
    "thumbHeight": [{ type: Input },],
    "disableThumb": [{ type: Input },],
    "thumbPosition": [{ type: Input },],
    "slidingDirection": [{ type: Input },],
    "destroyRef": [{ type: Input },],
    "indexChange": [{ type: Output },],
    "itemsChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryCoreComponent {
    constructor() {
        this.indexChange = new EventEmitter();
    }
    /**
     * Set thumbnails position ('top' | 'left' | 'right' | 'bottom')
     * @return {?}
     */
    get thumbPosition() {
        return this.config.thumbPosition;
    }
    /**
     * Set thumbnails position ('horizontal' | 'vertical')
     * @return {?}
     */
    get slidingDirection() {
        return this.config.slidingDirection;
    }
}
GalleryCoreComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-core',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <gallery-thumb *ngIf="config.thumb"
                  [state]="state"
                  [config]="config"
                  (indexChange)="indexChange.emit($event)">
    </gallery-thumb>
    <div class="g-box">
      <gallery-slider [state]="state"
                      [config]="config"
                      (indexChange)="indexChange.emit($event)">
        <gallery-nav *ngIf="config.nav && state.items.length > 1"
                    [state]="state"
                    [config]="config"
                    (indexChange)="indexChange.emit($event)">
        </gallery-nav>
      </gallery-slider>
      <gallery-dots *ngIf="config.dots"
                    [state]="state"
                    (indexChange)="indexChange.emit($event)">
      </gallery-dots>
      <gallery-counter *ngIf="config.counter"
                      [state]="state">
      </gallery-counter>
    </div>
  `
            },] },
];
/** @nocollapse */
GalleryCoreComponent.ctorParameters = () => [];
GalleryCoreComponent.propDecorators = {
    "state": [{ type: Input },],
    "config": [{ type: Input },],
    "indexChange": [{ type: Output },],
    "thumbPosition": [{ type: HostBinding, args: ['attr.thumbPosition',] },],
    "slidingDirection": [{ type: HostBinding, args: ['attr.slidingDirection',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryNavComponent {
    constructor() {
        this.indexChange = new EventEmitter();
    }
}
GalleryNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-nav',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <i *ngIf="config.loop || state.hasPrev" class="g-nav-prev" (tapClick)="indexChange.emit('prev')"></i>
    <i *ngIf="config.loop || state.hasNext" class="g-nav-next" (tapClick)="indexChange.emit('next')"></i>
  `
            },] },
];
/** @nocollapse */
GalleryNavComponent.ctorParameters = () => [];
GalleryNavComponent.propDecorators = {
    "state": [{ type: Input },],
    "config": [{ type: Input },],
    "indexChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryThumbComponent {
    /**
     * @param {?} _el
     */
    constructor(_el) {
        this._el = _el;
        this.stateStream$ = new BehaviorSubject({ value: 0, active: false });
        this.indexChange = new EventEmitter();
        this.thumbState$ = this.stateStream$.pipe(map((state) => ({
            style: this.thumbsStyle(state.value),
            active: state.active
        })));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.stateStream$.next({ value: 0, active: false });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.config.gestures && !this.config.disableThumb && Hammer) {
            this.mc = new Hammer(this._el.nativeElement);
            this.mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });
            // Slides thumbnails
            this.mc.on('pan', (e) => {
                switch (this.config.thumbPosition) {
                    case 'right':
                    case 'left':
                        this.stateStream$.next({ value: e.deltaY, active: true });
                        if (e.isFinal) {
                            this.stateStream$.next({ value: 0, active: false });
                            this.verticalPan(e);
                        }
                        break;
                    case 'top':
                    case 'bottom':
                        this.stateStream$.next({ value: e.deltaX, active: true });
                        if (e.isFinal) {
                            this.stateStream$.next({ value: 0, active: false });
                            this.horizontalPan(e);
                        }
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.mc) {
            this.mc.destroy();
        }
    }
    /**
     * @param {?} delta
     * @return {?}
     */
    thumbsStyle(delta) {
        let /** @type {?} */ value;
        switch (this.config.thumbPosition) {
            case 'top':
            case 'bottom':
                this.height = this.config.thumbHeight + 'px';
                value = -(this.state.currIndex * this.config.thumbWidth) - (this.config.thumbWidth / 2 - delta);
                return {
                    transform: `translate3d(${value}px, 0, 0)`,
                    width: this.state.items.length * this.config.thumbWidth + 'px',
                    height: '100%'
                };
            case 'left':
            case 'right':
                this.width = this.config.thumbWidth + 'px';
                value = -(this.state.currIndex * this.config.thumbHeight) - (this.config.thumbHeight / 2 - delta);
                return {
                    transform: `translate3d(0, ${value}px, 0)`,
                    width: '100%',
                    height: this.state.items.length * this.config.thumbHeight + 'px',
                };
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    verticalPan(e) {
        if (e.velocityY > 0.3) {
            this.indexChange.emit('prev');
        }
        else if (e.velocityY < -0.3) {
            this.indexChange.emit('next');
        }
        else {
            if (e.deltaY / 2 <= -this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('next');
            }
            else if (e.deltaY / 2 >= this.config.thumbHeight * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('prev');
            }
            else {
                this.indexChange.emit(this.state.currIndex);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    horizontalPan(e) {
        if (e.velocityX > 0.3) {
            this.indexChange.emit('prev');
        }
        else if (e.velocityX < -0.3) {
            this.indexChange.emit('next');
        }
        else {
            if (e.deltaX / 2 <= -this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('next');
            }
            else if (e.deltaX / 2 >= this.config.thumbWidth * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('prev');
            }
            else {
                this.indexChange.emit(this.state.currIndex);
            }
        }
    }
}
GalleryThumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-thumb',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <div *ngIf="thumbState$ | async; let thumbState"
         class="g-thumb-container">
      <div class="g-thumbs"
           [class.-no-transition]="thumbState.active"
           [ngStyle]="thumbState.style">
        <div *ngFor="let item of state.items;let i = index"
             class="g-thumb"
             [class.-current]="i === state.currIndex"
             (tapClick)="indexChange.emit(i)"
             [tapClickDisabled]="config.disableThumb">
          <ng-container [item]="item" type="thumb"></ng-container>
        </div>
      </div>
    </div>
  `
            },] },
];
/** @nocollapse */
GalleryThumbComponent.ctorParameters = () => [
    { type: ElementRef, },
];
GalleryThumbComponent.propDecorators = {
    "state": [{ type: Input },],
    "config": [{ type: Input },],
    "indexChange": [{ type: Output },],
    "height": [{ type: HostBinding, args: ['style.height',] },],
    "width": [{ type: HostBinding, args: ['style.width',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryDotsComponent {
    constructor() {
        this.indexChange = new EventEmitter();
    }
}
GalleryDotsComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-dots',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <div class="g-dot"
         *ngFor="let item of state.items; let i = index"
         (tapClick)="indexChange.emit(i)">
      <div class="g-dot-inner"
           [class.-current]="i === state.currIndex"></div>
    </div>
  `
            },] },
];
/** @nocollapse */
GalleryDotsComponent.ctorParameters = () => [];
GalleryDotsComponent.propDecorators = {
    "state": [{ type: Input },],
    "indexChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GallerySliderComponent {
    /**
     * @param {?} _el
     * @param {?} platform
     */
    constructor(_el, platform) {
        this._el = _el;
        this.platform = platform;
        this.stateStream$ = new BehaviorSubject({ value: 0, active: false });
        this.indexChange = new EventEmitter();
        this.sliderState$ = this.stateStream$.pipe(map((state) => ({
            style: this.sliderStyle(state.value),
            active: state.active
        })));
    }
    /**
     * @return {?}
     */
    viewDepth() {
        return { transform: `perspective(50px) translate3d(0, 0, ${-this.config.zoomOut}px)` };
    }
    /**
     * @param {?} delta
     * @return {?}
     */
    sliderStyle(delta) {
        switch (this.config.slidingDirection) {
            case 'horizontal':
                return {
                    transform: `translate3d(${-(this.state.currIndex * this._el.nativeElement.offsetWidth) + delta}px, 0, 0)`,
                    width: this._el.nativeElement.offsetWidth * this.state.items.length + 'px',
                    height: '100%'
                };
            case 'vertical':
                return {
                    transform: `translate3d(0, ${-(this.state.currIndex * this._el.nativeElement.offsetHeight) + delta}px, 0)`,
                    width: '100%',
                    height: this._el.nativeElement.offsetHeight * this.state.items.length + 'px',
                };
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.stateStream$.next({ value: 0, active: false });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.config.gestures && Hammer) {
            this.mc = new Hammer(this._el.nativeElement);
            this.mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });
            // Slides thumbnails
            this.mc.on('pan', (e) => {
                switch (this.config.slidingDirection) {
                    case 'horizontal':
                        this.stateStream$.next({ value: e.deltaX, active: true });
                        if (e.isFinal) {
                            this.stateStream$.next({ value: 0, active: false });
                            this.horizontalPan(e);
                        }
                        break;
                    case 'vertical':
                        this.stateStream$.next({ value: e.deltaY, active: true });
                        if (e.isFinal) {
                            this.stateStream$.next({ value: 0, active: false });
                            this.verticalPan(e);
                        }
                }
            });
        }
        // Rearrange slider on window resize
        if (isPlatformBrowser(this.platform)) {
            this.resizeSub$ = fromEvent(window, 'resize').pipe(debounceTime(200), tap(() => this.stateStream$.next(this.stateStream$.getValue()))).subscribe();
        }
        // Fix wrong slider width on init
        setTimeout(() => {
            this.stateStream$.next({ value: 0, active: false });
        }, 300);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.mc) {
            this.mc.destroy();
        }
        if (this.resizeSub$) {
            this.resizeSub$.unsubscribe();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    verticalPan(e) {
        if (e.velocityY > 0.3) {
            this.indexChange.emit('prev');
        }
        else if (e.velocityY < -0.3) {
            this.indexChange.emit('next');
        }
        else {
            if (e.deltaY / 2 <= -this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('next');
            }
            else if (e.deltaY / 2 >= this._el.nativeElement.offsetHeight * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('prev');
            }
            else {
                this.indexChange.emit(this.state.currIndex);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    horizontalPan(e) {
        if (e.velocityX > 0.3) {
            this.indexChange.emit('prev');
        }
        else if (e.velocityX < -0.3) {
            this.indexChange.emit('next');
        }
        else {
            if (e.deltaX / 2 <= -this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('next');
            }
            else if (e.deltaX / 2 >= this._el.nativeElement.offsetWidth * this.state.items.length / this.config.panSensitivity) {
                this.indexChange.emit('prev');
            }
            else {
                this.indexChange.emit(this.state.currIndex);
            }
        }
    }
}
GallerySliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-slider',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `
    <div *ngIf="sliderState$ | async; let sliderState"
         class="slides-container"
         [ngStyle]="viewDepth()">
      <div class="slides"
           [class.-no-transition]="sliderState.active"
           [ngStyle]="sliderState.style">
        <div *ngFor="let item of state.items" class="slide">
          <ng-container [item]="item"></ng-container>
        </div>
      </div>
    </div>
    <ng-content></ng-content>
  `
            },] },
];
/** @nocollapse */
GallerySliderComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
];
GallerySliderComponent.propDecorators = {
    "state": [{ type: Input },],
    "config": [{ type: Input },],
    "width": [{ type: Input },],
    "height": [{ type: Input },],
    "indexChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryCounterComponent {
}
GalleryCounterComponent.decorators = [
    { type: Component, args: [{
                selector: 'gallery-counter',
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                template: `<div class="g-counter">{{(state.currIndex + 1) + '/' + state.items.length}}</div>`
            },] },
];
/** @nocollapse */
GalleryCounterComponent.ctorParameters = () => [];
GalleryCounterComponent.propDecorators = {
    "state": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LazyDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        /**
         * Lazy load worker
         */
        this.worker$ = new Subject();
        this.loading = new EventEmitter();
        const /** @type {?} */ img = this.renderer.createElement('img');
        this.worker$.pipe(switchMap((imageSrc) => {
            /** Image is loading */
            this.loading.emit(true);
            /** Stop previously loading */
            img.src = imageSrc;
            /**
             * Image load success
             */
            const /** @type {?} */ imageSuccess = fromEvent(img, 'load').pipe(tap(() => {
                this.renderer.setStyle(this.el.nativeElement, 'backgroundImage', `url(${imageSrc})`);
                this.loading.emit(false);
            }));
            /**
             * Image load error
             */
            const /** @type {?} */ imageError = fromEvent(img, 'error').pipe(tap(() => this.loading.emit(false)));
            return zip(imageSuccess, imageError);
        })).subscribe();
    }
    /**
     * @param {?} imagePath
     * @return {?}
     */
    set lazyImage(imagePath) {
        this.getImage(imagePath);
    }
    /**
     * @param {?} imagePath
     * @return {?}
     */
    getImage(imagePath) {
        this.worker$.next(imagePath);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.worker$.unsubscribe();
    }
}
LazyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[lazyImage]'
            },] },
];
/** @nocollapse */
LazyDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
LazyDirective.propDecorators = {
    "lazyImage": [{ type: Input, args: ['lazyImage',] },],
    "loading": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** This directive enable tap if HammerJS is loaded, otherwise it falls back to normal click event */
class TapClickDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.tapClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setTapEvent();
    }
    /**
     * Enable gestures if hammer is loaded
     * @return {?}
     */
    setTapEvent() {
        if (typeof Hammer !== 'undefined') {
            // Use hammer.js tap event
            this.mc = new Hammer(this.el.nativeElement);
            this.mc.on('tap', () => {
                if (!this.tapClickDisabled) {
                    this.tapClick.emit(null);
                }
            });
        }
        else {
            // Use normal click event
            this.clickListener = this.renderer.listen(this.el.nativeElement, 'click', (e) => {
                e.stopPropagation();
                if (!this.tapClickDisabled) {
                    this.tapClick.emit(null);
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.mc) {
            this.mc.destroy();
        }
        else {
            this.clickListener();
        }
    }
}
TapClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tapClick]'
            },] },
];
/** @nocollapse */
TapClickDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
TapClickDirective.propDecorators = {
    "tapClickDisabled": [{ type: Input },],
    "tapClick": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GalleryItemDirective {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} viewContainerRef
     */
    constructor(componentFactoryResolver, viewContainerRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.type = 'slide';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ componentFactory = this.componentFactoryResolver
            .resolveComponentFactory(this.item[this.type === 'slide' ? 'component' : 'thumbComponent']);
        this.viewContainerRef.clear();
        const /** @type {?} */ componentRef = this.viewContainerRef.createComponent(componentFactory);
        const /** @type {?} */ galleryItem = componentRef.instance;
        galleryItem.data = this.item.data;
    }
}
GalleryItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[item]'
            },] },
];
/** @nocollapse */
GalleryItemDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
    { type: ViewContainerRef, },
];
GalleryItemDirective.propDecorators = {
    "item": [{ type: Input },],
    "type": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} galleryConfig
 * @return {?}
 */
function galleryFactory(galleryConfig) {
    return new Gallery(galleryConfig);
}
class GalleryModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: GalleryModule,
            providers: [
                {
                    provide: GALLERY_CONFIG,
                    useValue: config
                },
                {
                    provide: Gallery,
                    useFactory: galleryFactory,
                    deps: [GALLERY_CONFIG]
                }
            ]
        };
    }
}
GalleryModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    GalleryComponent,
                    GalleryCoreComponent,
                    GalleryNavComponent,
                    GalleryThumbComponent,
                    GalleryDotsComponent,
                    GallerySliderComponent,
                    GalleryCounterComponent,
                    ImageItemComponent,
                    VideoItemComponent,
                    IframeItemComponent,
                    ThumbnailItemComponent,
                    GalleryItemDirective,
                    LazyDirective,
                    TapClickDirective
                ],
                exports: [
                    GalleryComponent,
                    LazyDirective,
                    TapClickDirective
                ],
                entryComponents: [
                    IframeItemComponent,
                    ImageItemComponent,
                    VideoItemComponent,
                    ThumbnailItemComponent
                ]
            },] },
];
/** @nocollapse */
GalleryModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { Gallery, GalleryRef, GalleryAction, ImageItem, VideoItem, IframeItem, YoutubeItem, ImageItemComponent, VideoItemComponent, IframeItemComponent, ThumbnailItemComponent, galleryFactory, GalleryModule, GalleryCoreComponent as ɵe, GalleryCounterComponent as ɵj, GalleryDotsComponent as ɵh, GalleryNavComponent as ɵf, GallerySliderComponent as ɵi, GalleryThumbComponent as ɵg, GalleryComponent as ɵd, GalleryItemDirective as ɵo, LazyDirective as ɵp, TapClickDirective as ɵq, IframeItemComponent as ɵm, ImageItemComponent as ɵk, ThumbnailItemComponent as ɵn, VideoItemComponent as ɵl, GALLERY_CONFIG as ɵa };
//# sourceMappingURL=ngx-gallery-core.js.map
